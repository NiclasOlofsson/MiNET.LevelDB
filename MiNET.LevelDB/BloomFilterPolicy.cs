using System;
using System.Collections.Generic;
using System.IO;

namespace MiNET.LevelDB
{
	public class BloomFilterPolicy
	{
		private int _bitsPerKey;
		private int _k;
		private int _baseLg;
		private int _startOffsetArray;
		private Memory<byte> _filterBlock;

		public BloomFilterPolicy(int bitsPerKey = 10)
		{
			_bitsPerKey = bitsPerKey;
			_k = (int) Math.Max(1, Math.Min(30, (bitsPerKey*0.69)));
		}

		public string Name()
		{
			return "leveldb.BuiltinBloomFilter2";
		}

		public byte[] CreateFilter(List<byte[]> keys)
		{
			// Compute bloom filter size (in both bits and bytes)
			// For small n, we can see a very high false positive rate.
			// Fix it by enforcing a minimum bloom filter length.
			int bits = Math.Max(64, keys.Count*_bitsPerKey);
			int bytes = (int) ((bits + 7f)/8f);
			bits = bytes*8;

			byte[] array = new byte[bytes + 1];
			array[array.Length - 1] = (byte) _k; // Remember # of probes in filter

			foreach (var key in keys)
			{
				// Use double-hashing to generate a sequence of hash values.
				// See analysis in [Kirsch,Mitzenmacher 2006].
				uint h = BloomHash(key);
				uint delta = (h >> 17) | (h << 15); // Rotate right 17 bits
				for (int j = 0; j < _k; j++)
				{
					int bitpos = (int) (h%bits);
					array[bitpos/8] |= (byte) (1 << (bitpos%8));
					h += delta;
				}
			}

			return array;
		}

		private uint BloomHash(Span<byte> data)
		{
			return Hashing.Hash(data, 0xbc9f1d34); //avoid data copy
		}

		public bool KeyMayMatch(Span<byte> key, ulong position)
		{
			var num = (_filterBlock.Length - 5)/sizeof(int);
			int index = (int) (position >> _baseLg);
			if (index > num) return false; // Maybe even on errors


			var start = BitConverter.ToInt32(_filterBlock.Slice(_startOffsetArray + index*sizeof(int), 4).Span);
			var limit = BitConverter.ToInt32(_filterBlock.Slice(_startOffsetArray + index*sizeof(int) + sizeof(int), 4).Span);

			if (start > limit || limit > _filterBlock.Length)
				return false; // empty filters do no match any keys

			return KeyMayMatch(key, _filterBlock.Slice(start, limit).Span);
		}

		public bool KeyMayMatch(Span<byte> key, Span<byte> data)
		{
			int len = data.Length;
			if (len < 2)
			{
				return false;
			}

			int bits = (len - 1)*8;

			// Use the encoded k so that we can read filters generated by
			// bloom filters created using different parameters.
			int k = data[len - 1];
			if (k > 30)
			{
				// Reserved for potentially new encodings for short bloom filters.
				// Consider it a match.
				return true;
			}

			uint h = BloomHash(key);
			uint delta = (h >> 17) | (h << 15); // Rotate right 17 bits
			for (int j = 0; j < k; j++)
			{
				int bitpos = (int) (h%bits);
				if ((data[bitpos/8] & (1 << (bitpos%8))) == 0)
				{
					return false;
				}
				h += delta;
			}

			return true;
		}

		/**
		* Convert an unsigned int into a long
		*/
		private long ToLong(uint h)
		{
			return h;
		}

		public object Parse(byte[] filterBlock)
		{
			var stream = new MemoryStream(filterBlock);
			var reader = new BinaryReader(stream);

			if (stream.Length < 5) return null;

			stream.Seek(-1, SeekOrigin.End);
			_baseLg = reader.ReadByte();
			stream.Seek(-5, SeekOrigin.End);
			_startOffsetArray = reader.ReadInt32();

			if (_startOffsetArray > stream.Length - 5) return null;

			_filterBlock = filterBlock;

			return null;
		}
	}
}